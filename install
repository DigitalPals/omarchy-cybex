#!/bin/bash

################################################################################
# Omarchy Linux Post-Installation Setup Script
# https://omarchy.org
#
# This script sets up personal preferences after a fresh Omarchy installation.
# It is designed to be idempotent - safe to run multiple times.
#
# Usage:
#   ./install                - Launch interactive TUI installer
#   ./install all            - Install everything except mainline kernel
#   ./install claude ssh     - Install specific components
#   ./install mainline       - Install mainline kernel only
#   ./install --help         - Show CLI help and available options
#
# Run without arguments to launch the TUI installer.
################################################################################

set -e  # Exit on error

# Trap handler for cleanup on failure
cleanup() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        echo -e "\n${RED}✗${NC} Installation failed with exit code $exit_code"
        echo -e "${YELLOW}Some changes may have been made. Please review and potentially rollback manually.${NC}"
    fi
}
trap cleanup EXIT

# Color codes for pretty output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configuration constants
MIN_ROOT_SPACE_MB=1024
MIN_BOOT_SPACE_MB=100
MIN_NODE_VERSION=14

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

################################################################################
# TUI Bootstrap - Launch TUI when no arguments provided
################################################################################

if [ $# -eq 0 ]; then
    RUST_TUI="$SCRIPT_DIR/rust-tui/target/release/omarchy-cybex-installer"

    # Prefer Rust TUI if available
    if [ -x "$RUST_TUI" ]; then
        exec "$RUST_TUI" "$SCRIPT_DIR"
    fi

    # Fall back to Python TUI
    TUI_DIR="$SCRIPT_DIR/tui"
    VENV_DIR="$SCRIPT_DIR/.venv"

    # Check if TUI directory exists
    if [ ! -d "$TUI_DIR" ]; then
        echo -e "${RED}✗${NC} TUI directory not found at $TUI_DIR"
        echo -e "Falling back to CLI mode. Run with --help for options."
        echo ""
        # Fall through to show_usage below
    else
        # Check if Python 3 is available
        if ! command -v python3 &>/dev/null; then
            echo -e "${YELLOW}⚠${NC} Python 3 is required for the TUI installer."
            echo -e "Install with: ${CYAN}sudo pacman -S python${NC}"
            echo ""
            echo -e "Alternatively, use CLI mode: ${CYAN}./install --help${NC}"
            exit 1
        fi

        # Create venv if it doesn't exist
        if [ ! -d "$VENV_DIR" ]; then
            echo -e "${CYAN}▶${NC} Setting up TUI environment (first run)..."
            python3 -m venv "$VENV_DIR"
            "$VENV_DIR/bin/pip" install --quiet --upgrade pip
            echo -e "${CYAN}▶${NC} Installing Textual..."
            "$VENV_DIR/bin/pip" install --quiet textual
            echo -e "${GREEN}✓${NC} TUI environment ready!"
            echo ""
        fi

        # Launch TUI (run as module for proper imports)
        cd "$SCRIPT_DIR"
        exec "$VENV_DIR/bin/python" -m tui.main "$SCRIPT_DIR"
    fi
fi

################################################################################
# Helper Functions
################################################################################

print_header() {
    echo -e "\n${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${MAGENTA}  $1${NC}"
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

print_step() {
    echo -e "${BLUE}▶${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_skip() {
    echo -e "${YELLOW}⊙${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

package_installed() {
    pacman -Q "$1" >/dev/null 2>&1
}

# Create a timestamped backup of a file
create_backup() {
    local file="$1"
    if [ -f "$file" ]; then
        local backup="${file}.bak.$(date +%Y%m%d%H%M%S)"
        cp "$file" "$backup"
        echo "$backup"
        return 0
    fi
    return 1
}

# Remove lines added by this script from a file
remove_script_lines() {
    local file="$1"
    local marker="$2"  # Comment marker to identify our additions (e.g., "Added by Omarchy")

    if [ ! -f "$file" ]; then
        return 0
    fi

    # Create temp file without our additions
    local temp_file
    temp_file=$(mktemp) || {
        print_error "Failed to create temp file for $file"
        return 1
    }
    local skip_next_non_empty=false

    while IFS= read -r line; do
        # If we found the marker in the previous iteration, skip non-empty lines
        if [ "$skip_next_non_empty" = true ]; then
            if [ -n "$line" ]; then
                # Skip this non-empty line (the actual command/export)
                skip_next_non_empty=false
                continue
            else
                # Skip empty lines between marker and command
                continue
            fi
        fi

        # Check if this line contains our marker
        if echo "$line" | grep -q "$marker"; then
            # Skip the marker line and set flag to skip next non-empty line
            skip_next_non_empty=true
            continue
        fi

        # Keep this line
        echo "$line" >> "$temp_file"
    done < "$file"

    # Validate temp file before replacing (allow empty result if original was effectively empty)
    if [ -s "$temp_file" ] || [ ! -s "$file" ]; then
        mv "$temp_file" "$file" || {
            print_error "Failed to update $file"
            rm -f "$temp_file"
            return 1
        }
    else
        # Original had content but result is empty - something went wrong
        print_error "Temp file is unexpectedly empty, keeping original $file"
        rm -f "$temp_file"
        return 1
    fi
}

# Deploy a config file with backup and comparison
# Usage: deploy_config_file <src> <dest> <name> [executable]
deploy_config_file() {
    local src="$1"
    local dest="$2"
    local name="$3"
    local executable="${4:-false}"

    if [ ! -f "$src" ]; then
        print_error "Source $name not found at $src"
        print_error "Skipping $name configuration..."
        return 1
    fi

    mkdir -p "$(dirname "$dest")"

    if [ -f "$dest" ]; then
        if cmp -s "$src" "$dest"; then
            print_skip "$name is already up to date"
            return 0
        fi
        print_step "Backing up existing $name..."
        BACKUP_FILE=$(create_backup "$dest")
        print_success "Backup created at $BACKUP_FILE"
        print_step "Updating $name..."
        cp "$src" "$dest"
        [ "$executable" = true ] && chmod +x "$dest"
        print_success "$name updated"
    else
        print_step "Installing $name to $dest..."
        cp "$src" "$dest"
        [ "$executable" = true ] && chmod +x "$dest"
        print_success "$name configured"
    fi
    return 0
}

show_usage() {
    echo -e "${BOLD}${CYAN}Omarchy Linux Post-Installation Setup Script${NC}"
    echo -e "${CYAN}https://omarchy.org${NC}"
    echo ""
    echo -e "${BOLD}USAGE:${NC}"
    echo -e "  $0 [OPTION]..."
    echo -e "  $0 uninstall [OPTION]..."
    echo ""
    echo -e "${BOLD}DESCRIPTION:${NC}"
    echo -e "  Configure and install various components for your Omarchy Linux system."
    echo -e "  This script is idempotent - safe to run multiple times."
    echo ""
    echo -e "${BOLD}OPTIONS:${NC}"
    echo -e "  ${GREEN}all${NC}              Install all components (except mainline kernel)"
    echo -e "  ${GREEN}claude${NC}           Install Claude Code CLI"
    echo -e "  ${GREEN}codex${NC}            Install OpenAI Codex CLI"
    echo -e "  ${GREEN}screensaver${NC}      Configure custom screensaver"
    echo -e "  ${GREEN}plymouth${NC}         Install Cybex Plymouth boot theme"
    echo -e "  ${GREEN}fish${NC}             Install Fish shell with Starship prompt (via omarchy-fish)"
    echo -e "  ${GREEN}hyprland${NC}         Configure Hyprland bindings (alias: hyprland-bindings)"
    echo -e "  ${GREEN}waycorner${NC}        Install and configure hot corners for Hyprland"
    echo -e "  ${GREEN}waybar${NC}           Configure Waybar idle toggle indicator"
    echo -e "  ${GREEN}ssh${NC}              Generate SSH key for GitHub (alias: ssh-key)"
    echo -e "  ${GREEN}brave${NC}            Install Brave browser and set as default"
    echo -e "  ${GREEN}mainline${NC}         Install and configure mainline kernel (Chaotic-AUR)"
    echo -e "  ${GREEN}passwordless-sudo${NC}  Enable passwordless sudo for current user"
    echo -e "  ${GREEN}noctalia${NC}         Install Noctalia Shell (replaces Waybar)"
    echo -e "  ${GREEN}looknfeel${NC}        Install improved Hyprland animations"
    echo ""
    echo -e "${BOLD}UNINSTALL:${NC}"
    echo -e "  ${YELLOW}uninstall${NC} all              Remove all installed components"
    echo -e "  ${YELLOW}uninstall${NC} [option]         Remove specific component"
    echo ""
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo -e "  $0 all                    # Install everything except mainline kernel"
    echo -e "  $0 claude ssh             # Install Claude Code and generate SSH key"
    echo -e "  $0 mainline               # Only configure mainline kernel"
    echo -e "  $0 fish codex             # Install Fish shell and Codex CLI"
    echo -e "  $0 uninstall all          # Remove all installed components"
    echo ""
    echo -e "${BOLD}NOTES:${NC}"
    echo -e "  • Multiple options can be combined in a single command"
    echo -e "  • The script will request sudo privileges when needed"
    echo -e "  • Some components require a reboot to take effect (kernel, Plymouth theme)"
    echo -e "  • Uninstall creates backups and restores original configurations when possible"
    echo -e "  • SSH keys cannot be uninstalled for safety reasons"
    echo -e "  • Run without arguments to show this help message"
    echo ""
}

################################################################################
# Command Line Arguments
################################################################################

# Initialize mode and flags
UNINSTALL_MODE=false
INSTALL_ALL=false
INSTALL_CLAUDE=false
INSTALL_CODEX=false
INSTALL_SCREENSAVER=false
INSTALL_PLYMOUTH=false
INSTALL_FISH=false
INSTALL_HYPRLAND_BINDINGS=false
INSTALL_WAYCORNER=false
INSTALL_WAYBAR=false
INSTALL_SSH=false
INSTALL_BRAVE=false
INSTALL_MAINLINE=false
INSTALL_PASSWORDLESS_SUDO=false
INSTALL_NOCTALIA=false
INSTALL_LOOKNFEEL=false

# Show help if --help is provided
if [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ "$1" = "help" ]; then
    show_usage
    exit 0
fi

# Check if first argument is "uninstall"
if [ "$1" = "uninstall" ]; then
    UNINSTALL_MODE=true
    shift  # Remove "uninstall" from arguments

    # Show help if no uninstall target specified
    if [ $# -eq 0 ]; then
        print_error "Please specify what to uninstall (e.g., 'uninstall all' or 'uninstall waycorner')"
        echo ""
        show_usage
        exit 1
    fi
fi

# Parse all command line arguments
for arg in "$@"; do
    case "$arg" in
        all)
            INSTALL_ALL=true
            ;;
        claude)
            INSTALL_CLAUDE=true
            ;;
        codex)
            INSTALL_CODEX=true
            ;;
        screensaver)
            INSTALL_SCREENSAVER=true
            ;;
        plymouth)
            INSTALL_PLYMOUTH=true
            ;;
        fish)
            INSTALL_FISH=true
            ;;
        hyprland|hyprland-bindings)
            INSTALL_HYPRLAND_BINDINGS=true
            ;;
        waycorner)
            INSTALL_WAYCORNER=true
            ;;
        waybar)
            INSTALL_WAYBAR=true
            ;;
        ssh|ssh-key)
            if [ "$UNINSTALL_MODE" = true ]; then
                print_error "SSH keys cannot be uninstalled for safety reasons"
                exit 1
            fi
            INSTALL_SSH=true
            ;;
        brave)
            INSTALL_BRAVE=true
            ;;
        mainline)
            INSTALL_MAINLINE=true
            ;;
        passwordless-sudo)
            INSTALL_PASSWORDLESS_SUDO=true
            ;;
        noctalia|noctalia-shell)
            INSTALL_NOCTALIA=true
            ;;
        looknfeel)
            INSTALL_LOOKNFEEL=true
            ;;
        *)
            print_error "Unknown parameter: $arg"
            echo ""
            show_usage
            exit 1
            ;;
    esac
done

# If 'all' is specified, enable everything except mainline
if [ "$INSTALL_ALL" = true ]; then
    INSTALL_CLAUDE=true
    INSTALL_CODEX=true
    INSTALL_SCREENSAVER=true
    INSTALL_PLYMOUTH=true
    INSTALL_FISH=true
    INSTALL_HYPRLAND_BINDINGS=true
    INSTALL_WAYCORNER=true
    INSTALL_WAYBAR=true
    INSTALL_SSH=true
    INSTALL_BRAVE=true
    INSTALL_LOOKNFEEL=true
fi

################################################################################
# Uninstall Functions
################################################################################

if [ "$UNINSTALL_MODE" = true ]; then
    print_header "Starting Omarchy Component Uninstall"

    # Check if running as root
    if [ "$EUID" -eq 0 ]; then
        print_error "Please do not run this script as root or with sudo."
        print_error "The script will request sudo when needed."
        exit 1
    fi

    # Uninstall Claude Code
    if [ "$INSTALL_CLAUDE" = true ]; then
        print_header "Uninstalling Claude Code"

        if command_exists claude; then
            print_step "Removing Claude Code..."
            npm uninstall -g @anthropic-ai/claude-code --prefix "$HOME/.local"
            print_success "Claude Code removed"
        else
            print_skip "Claude Code is not installed"
        fi

        # Remove PATH entry from .bashrc only if Codex is also not installed
        if [ -f "$HOME/.bashrc" ]; then
            if ! command_exists codex; then
                print_step "Cleaning PATH from .bashrc..."
                remove_script_lines "$HOME/.bashrc" "Added by Omarchy"
                print_success "PATH entries cleaned from .bashrc"
            else
                print_skip "Keeping PATH entry (Codex is still installed)"
            fi
        fi
    fi

    # Uninstall Codex CLI
    if [ "$INSTALL_CODEX" = true ]; then
        print_header "Uninstalling Codex CLI"

        if command_exists codex; then
            print_step "Removing Codex CLI..."
            npm uninstall -g @openai/codex --prefix "$HOME/.local"
            print_success "Codex CLI removed"
        else
            print_skip "Codex CLI is not installed"
        fi

        # Remove PATH entry from .bashrc only if Claude is also not installed
        if [ -f "$HOME/.bashrc" ]; then
            if ! command_exists claude; then
                print_step "Cleaning PATH from .bashrc..."
                remove_script_lines "$HOME/.bashrc" "Added by Omarchy"
                print_success "PATH entries cleaned from .bashrc"
            else
                print_skip "Keeping PATH entry (Claude Code is still installed)"
            fi
        fi
    fi

    # Uninstall screensaver
    if [ "$INSTALL_SCREENSAVER" = true ]; then
        print_header "Removing Custom Screensaver"

        SCREENSAVER_DEST="$HOME/.config/omarchy/branding/screensaver.txt"

        if [ -f "$SCREENSAVER_DEST" ]; then
            # Find most recent backup
            BACKUP=$(ls -t "${SCREENSAVER_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring backup from $BACKUP..."
                cp "$BACKUP" "$SCREENSAVER_DEST"
                print_success "Screensaver backup restored"
            else
                print_step "Removing custom screensaver..."
                rm "$SCREENSAVER_DEST"
                print_success "Custom screensaver removed"
            fi
        else
            print_skip "Custom screensaver not found"
        fi
    fi

    # Uninstall Plymouth theme
    if [ "$INSTALL_PLYMOUTH" = true ]; then
        print_header "Uninstalling Plymouth Theme"

        if command_exists plymouth-set-default-theme; then
            CURRENT_THEME=$(sudo plymouth-set-default-theme)

            if [ "$CURRENT_THEME" = "cybex" ]; then
                print_step "Resetting Plymouth theme to default..."
                sudo plymouth-set-default-theme -R spinner
                print_success "Plymouth theme reset to spinner"

                print_step "Rebuilding initramfs..."
                sudo mkinitcpio -P
                print_success "Initramfs rebuilt"
            else
                print_skip "Plymouth theme is not set to cybex"
            fi

            # Remove theme directory
            if sudo test -d "/usr/share/plymouth/themes/cybex"; then
                print_step "Removing cybex theme directory..."
                sudo rm -rf "/usr/share/plymouth/themes/cybex"
                print_success "Cybex theme directory removed"
            fi
        else
            print_skip "Plymouth not installed"
        fi
    fi

    # Uninstall Fish shell configuration
    if [ "$INSTALL_FISH" = true ]; then
        print_header "Removing Fish Shell Configuration"

        # Remove omarchy-fish package
        if package_installed "omarchy-fish"; then
            echo -e "${YELLOW}Warning: This will remove omarchy-fish and restore bash as your shell.${NC}"
            read -p "Are you sure you want to continue? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                print_step "Removing omarchy-fish package..."
                sudo pacman -R --noconfirm omarchy-fish
                print_success "omarchy-fish removed"

                # Restore bash backup created by omarchy-setup-fish
                BASHRC="$HOME/.bashrc"
                BASHRC_BACKUP=$(ls -t "${BASHRC}.backup-"* 2>/dev/null | head -1)

                if [ -n "$BASHRC_BACKUP" ]; then
                    print_step "Restoring .bashrc backup from omarchy-setup-fish..."
                    cp "$BASHRC_BACKUP" "$BASHRC"
                    print_success ".bashrc restored"
                else
                    print_skip "No .bashrc backup found from omarchy-setup-fish"
                fi
            else
                print_skip "Skipping omarchy-fish removal"
            fi
        else
            print_skip "omarchy-fish package is not installed"
        fi

        # Restore Starship configuration
        STARSHIP_DEST="$HOME/.config/starship.toml"
        if [ -f "$STARSHIP_DEST" ]; then
            BACKUP=$(ls -t "${STARSHIP_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring Starship backup from $BACKUP..."
                cp "$BACKUP" "$STARSHIP_DEST"
                print_success "Starship configuration backup restored"
            else
                print_step "Removing Starship configuration..."
                rm "$STARSHIP_DEST"
                print_success "Starship configuration removed"
            fi
        else
            print_skip "Starship configuration not found"
        fi

        # Remove Fish config
        FISH_CONFIG="$HOME/.config/fish/config.fish"
        if [ -f "$FISH_CONFIG" ]; then
            BACKUP=$(ls -t "${FISH_CONFIG}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring Fish config backup from $BACKUP..."
                cp "$BACKUP" "$FISH_CONFIG"
                print_success "Fish configuration backup restored"
            else
                print_step "Removing Fish configuration..."
                rm "$FISH_CONFIG"
                print_success "Fish configuration removed"
            fi
        else
            print_skip "Fish configuration not found"
        fi
    fi

    # Uninstall Hyprland bindings
    if [ "$INSTALL_HYPRLAND_BINDINGS" = true ]; then
        print_header "Removing Hyprland Configuration"

        HYPRLAND_BINDINGS_DEST="$HOME/.config/hypr/bindings.conf"
        HYPRLAND_INPUT_DEST="$HOME/.config/hypr/input.conf"

        # Restore bindings.conf
        if [ -f "$HYPRLAND_BINDINGS_DEST" ]; then
            BACKUP=$(ls -t "${HYPRLAND_BINDINGS_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring bindings.conf backup from $BACKUP..."
                cp "$BACKUP" "$HYPRLAND_BINDINGS_DEST"
                print_success "Hyprland bindings restored"
            else
                print_step "Removing bindings.conf..."
                rm "$HYPRLAND_BINDINGS_DEST"
                print_success "Hyprland bindings removed"
            fi
        fi

        # Restore input.conf
        if [ -f "$HYPRLAND_INPUT_DEST" ]; then
            BACKUP=$(ls -t "${HYPRLAND_INPUT_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring input.conf backup from $BACKUP..."
                cp "$BACKUP" "$HYPRLAND_INPUT_DEST"
                print_success "Hyprland input configuration restored"
            else
                print_step "Removing input.conf..."
                rm "$HYPRLAND_INPUT_DEST"
                print_success "Hyprland input configuration removed"
            fi
        fi
    fi

    # Uninstall waycorner
    if [ "$INSTALL_WAYCORNER" = true ]; then
        print_header "Uninstalling Waycorner"

        # Kill running process
        if pgrep -x waycorner >/dev/null 2>&1; then
            print_step "Stopping waycorner..."
            pkill -x waycorner
            print_success "waycorner stopped"
        fi

        # Remove binary
        if [ -f "$HOME/.cargo/bin/waycorner" ]; then
            print_step "Removing waycorner binary..."
            rm "$HOME/.cargo/bin/waycorner"
            print_success "waycorner binary removed"
        fi

        # Restore or remove configuration
        WAYCORNER_DEST="$HOME/.config/waycorner/config.toml"
        if [ -f "$WAYCORNER_DEST" ]; then
            BACKUP=$(ls -t "${WAYCORNER_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring waycorner backup from $BACKUP..."
                cp "$BACKUP" "$WAYCORNER_DEST"
                print_success "waycorner configuration restored"
            else
                print_step "Removing waycorner configuration..."
                rm -rf "$HOME/.config/waycorner"
                print_success "waycorner configuration removed"
            fi
        fi

        # Remove from autostart.conf
        HYPRLAND_AUTOSTART="$HOME/.config/hypr/autostart.conf"
        if [ -f "$HYPRLAND_AUTOSTART" ]; then
            print_step "Removing waycorner from Hyprland autostart..."
            remove_script_lines "$HYPRLAND_AUTOSTART" "Hot corners"
            print_success "waycorner removed from autostart"
        fi
    fi

    # Uninstall Waybar configuration
    if [ "$INSTALL_WAYBAR" = true ]; then
        print_header "Removing Waybar Configuration"

        WAYBAR_CONFIG_DEST="$HOME/.config/waybar/config.jsonc"
        WAYBAR_STYLE_DEST="$HOME/.config/waybar/style.css"
        INDICATOR_DEST="$HOME/.local/share/omarchy/default/waybar/indicators/idle-toggle.sh"

        # Restore config.jsonc
        if [ -f "$WAYBAR_CONFIG_DEST" ]; then
            BACKUP=$(ls -t "${WAYBAR_CONFIG_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring waybar config backup from $BACKUP..."
                cp "$BACKUP" "$WAYBAR_CONFIG_DEST"
                print_success "Waybar configuration restored"
            else
                print_skip "No waybar config backup found"
            fi
        fi

        # Restore style.css
        if [ -f "$WAYBAR_STYLE_DEST" ]; then
            BACKUP=$(ls -t "${WAYBAR_STYLE_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring waybar style backup from $BACKUP..."
                cp "$BACKUP" "$WAYBAR_STYLE_DEST"
                print_success "Waybar style restored"
            else
                print_skip "No waybar style backup found"
            fi
        fi

        # Remove indicator script
        if [ -f "$INDICATOR_DEST" ]; then
            print_step "Removing idle toggle indicator..."
            rm "$INDICATOR_DEST"
            print_success "Idle toggle indicator removed"
        fi

        # Restart waybar
        print_step "Restarting Waybar..."
        if command_exists omarchy-restart-waybar; then
            omarchy-restart-waybar &>/dev/null
            print_success "Waybar restarted"
        else
            if pgrep -x waybar >/dev/null 2>&1; then
                pkill -x waybar
                sleep 0.5
                waybar &>/dev/null &
                print_success "Waybar restarted"
            else
                print_skip "Waybar is not running"
            fi
        fi
    fi

    # Uninstall Brave browser
    if [ "$INSTALL_BRAVE" = true ]; then
        print_header "Uninstalling Brave Browser"

        if package_installed "brave-bin"; then
            echo -e "${YELLOW}Warning: This will remove Brave browser.${NC}"
            read -p "Are you sure you want to continue? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                print_step "Removing brave-bin package..."
                yay -R --noconfirm brave-bin
                print_success "Brave browser removed"
            else
                print_skip "Skipping Brave removal"
            fi
        else
            print_skip "Brave browser is not installed"
        fi

        # Remove BROWSER=brave from uwsm default file
        UWSM_DEFAULT="$HOME/.config/uwsm/default"
        if [ -f "$UWSM_DEFAULT" ]; then
            if grep -q "^export BROWSER=brave" "$UWSM_DEFAULT" 2>/dev/null; then
                print_step "Removing BROWSER setting from uwsm default..."
                # Create backup first
                BACKUP_FILE=$(create_backup "$UWSM_DEFAULT")
                if [ -n "$BACKUP_FILE" ]; then
                    print_success "Backup created at $BACKUP_FILE"
                fi
                # Remove the BROWSER=brave line
                sed -i '/^export BROWSER=brave/d' "$UWSM_DEFAULT"
                print_success "BROWSER setting removed from uwsm default"
            else
                print_skip "BROWSER setting not found in uwsm default"
            fi
        fi
    fi

    # Uninstall mainline kernel
    if [ "$INSTALL_MAINLINE" = true ]; then
        print_header "Uninstalling Mainline Kernel"

        echo -e "${YELLOW}Warning: This will remove the mainline kernel and reset bootloader.${NC}"
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if package_installed "linux-mainline"; then
                print_step "Removing linux-mainline kernel..."
                sudo pacman -R --noconfirm linux-mainline
                print_success "linux-mainline kernel removed"

                # Reset bootloader to default kernel
                print_step "Resetting bootloader to default kernel..."
                if [ -f /boot/limine.conf ]; then
                    sudo sed -i 's/^default_entry:.*/default_entry: 0/' /boot/limine.conf
                    print_success "Limine bootloader reset to first entry"
                elif command_exists grub-mkconfig; then
                    sudo grub-mkconfig -o /boot/grub/grub.cfg
                    print_success "GRUB configuration updated"
                elif command_exists bootctl; then
                    # Reset to first available entry
                    FIRST_ENTRY=$(ls /boot/loader/entries/*.conf 2>/dev/null | head -1 | xargs basename 2>/dev/null)
                    if [ -n "$FIRST_ENTRY" ]; then
                        echo "default $FIRST_ENTRY" | sudo tee /boot/loader/loader.conf >/dev/null
                        print_success "systemd-boot reset to $FIRST_ENTRY"
                    fi
                fi
            else
                print_skip "linux-mainline kernel is not installed"
            fi
        else
            print_skip "Skipping mainline kernel removal"
        fi
    fi

    # Uninstall passwordless sudo
    if [ "$INSTALL_PASSWORDLESS_SUDO" = true ]; then
        print_header "Removing Passwordless Sudo"

        SUDOERS_FILE="/etc/sudoers.d/$(whoami)"

        if sudo test -f "$SUDOERS_FILE"; then
            print_step "Removing sudoers file..."
            sudo rm "$SUDOERS_FILE"
            print_success "Passwordless sudo removed"
            echo -e "${YELLOW}Note: You will need to enter your password for sudo commands now.${NC}"
        else
            print_skip "Passwordless sudo is not configured"
        fi
    fi

    # Uninstall Noctalia Shell
    if [ "$INSTALL_NOCTALIA" = true ]; then
        print_header "Uninstalling Noctalia Shell"

        # Re-enable default Omarchy autostart in hyprland.conf
        HYPRLAND_CONF="$HOME/.config/hypr/hyprland.conf"
        if [ -f "$HYPRLAND_CONF" ] && grep -q "# source = ~/.local/share/omarchy/default/hypr/autostart.conf.*Disabled by Cybex" "$HYPRLAND_CONF"; then
            print_step "Re-enabling Omarchy default autostart..."
            sed -i 's|# source = ~/.local/share/omarchy/default/hypr/autostart.conf.*Disabled by Cybex.*|source = ~/.local/share/omarchy/default/hypr/autostart.conf|' "$HYPRLAND_CONF"
            print_success "Omarchy default autostart re-enabled"
        else
            print_skip "Omarchy default autostart already enabled"
        fi

        # Remove from autostart.conf
        HYPRLAND_AUTOSTART="$HOME/.config/hypr/autostart.conf"
        if [ -f "$HYPRLAND_AUTOSTART" ] && grep -q "noctalia-shell" "$HYPRLAND_AUTOSTART"; then
            print_step "Removing Noctalia Shell from Hyprland autostart..."
            remove_script_lines "$HYPRLAND_AUTOSTART" "Noctalia Shell"
            print_success "Noctalia Shell removed from autostart"
        else
            print_skip "Noctalia Shell not found in autostart"
        fi

        # Remove Noctalia keybindings from bindings.conf
        HYPRLAND_BINDINGS="$HOME/.config/hypr/bindings.conf"
        if [ -f "$HYPRLAND_BINDINGS" ] && grep -q "Noctalia Shell keybindings" "$HYPRLAND_BINDINGS"; then
            print_step "Removing Noctalia keybindings..."
            # Remove the marker and all following bind lines until next blank line or EOF
            sed -i '/# Added by Cybex - Noctalia Shell keybindings/,/^$/d' "$HYPRLAND_BINDINGS"
            print_success "Noctalia keybindings removed"
        fi

        # Kill Noctalia Shell process (quickshell with noctalia-shell config)
        if pgrep -f "qs.*noctalia-shell" >/dev/null 2>&1; then
            print_step "Stopping Noctalia Shell..."
            pkill -f "qs.*noctalia-shell"
            sleep 0.3
            print_success "Noctalia Shell stopped"
        else
            print_skip "Noctalia Shell is not running"
        fi

        # Restart Omarchy services that were disabled by Noctalia
        print_step "Restarting Omarchy services..."

        # Restart Waybar
        if ! pgrep -x waybar >/dev/null 2>&1; then
            uwsm-app -- waybar &>/dev/null &
        fi

        # Restart Mako (notification daemon)
        if ! pgrep -x mako >/dev/null 2>&1; then
            uwsm-app -- mako &>/dev/null &
        fi

        # Restart SwayOSD (volume/brightness OSD)
        if ! pgrep -x swayosd-server >/dev/null 2>&1; then
            uwsm-app -- swayosd-server &>/dev/null &
        fi

        # Restart swaybg (wallpaper)
        if ! pgrep -x swaybg >/dev/null 2>&1; then
            uwsm-app -- swaybg -m fill -i "$HOME/.local/share/omarchy/wallpaper" &>/dev/null &
        fi

        sleep 0.5
        if pgrep -x waybar >/dev/null 2>&1; then
            print_success "Omarchy services restarted (waybar, mako, swayosd, swaybg)"
        else
            print_skip "Some services may need manual restart or session reload"
        fi

        # Optionally remove package
        if package_installed "noctalia-shell"; then
            echo ""
            read -p "Remove noctalia-shell package? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                print_step "Removing noctalia-shell package..."
                yay -R --noconfirm noctalia-shell
                print_success "noctalia-shell package removed"
            else
                print_skip "Keeping noctalia-shell package"
            fi
        fi
    fi

    # Uninstall looknfeel (animations)
    if [ "$INSTALL_LOOKNFEEL" = true ]; then
        print_header "Removing Hyprland Animations"

        LOOKNFEEL_DEST="$HOME/.config/hypr/looknfeel.conf"

        if [ -f "$LOOKNFEEL_DEST" ]; then
            BACKUP=$(ls -t "${LOOKNFEEL_DEST}.bak."* 2>/dev/null | head -1)

            if [ -n "$BACKUP" ]; then
                print_step "Restoring looknfeel.conf backup from $BACKUP..."
                cp "$BACKUP" "$LOOKNFEEL_DEST"
                print_success "Hyprland looknfeel configuration restored"
            else
                print_step "Removing looknfeel.conf..."
                rm "$LOOKNFEEL_DEST"
                print_success "Hyprland looknfeel configuration removed"
            fi
        else
            print_skip "Hyprland looknfeel configuration not found"
        fi
    fi

    print_header "Uninstall Complete!"
    echo -e "${GREEN}Selected components have been uninstalled.${NC}\n"

    exit 0
fi

################################################################################
# Main Installation Steps
################################################################################

print_header "Starting Omarchy Post-Installation Setup"

# Check if running as root
if [ "$EUID" -eq 0 ]; then
    print_error "Please do not run this script as root or with sudo."
    print_error "The script will request sudo when needed."
    exit 1
fi

################################################################################
# System Validation Checks
################################################################################

# Determine what validation checks are needed based on selected components
NEED_SUDO=false
NEED_INTERNET=false
NEED_DISK_SPACE=false

# Components that require sudo
if [ "$INSTALL_MAINLINE" = true ] || [ "$INSTALL_PLYMOUTH" = true ] || [ "$INSTALL_BRAVE" = true ]; then
    NEED_SUDO=true
fi

# Components that require internet
if [ "$INSTALL_CLAUDE" = true ] || [ "$INSTALL_CODEX" = true ] || [ "$INSTALL_MAINLINE" = true ] || [ "$INSTALL_WAYCORNER" = true ] || [ "$INSTALL_BRAVE" = true ] || [ "$INSTALL_NOCTALIA" = true ]; then
    NEED_INTERNET=true
fi

# Components that require significant disk space
if [ "$INSTALL_MAINLINE" = true ] || [ "$INSTALL_PLYMOUTH" = true ]; then
    NEED_DISK_SPACE=true
fi

# Only run validation checks if needed
if [ "$NEED_SUDO" = true ] || [ "$NEED_INTERNET" = true ] || [ "$NEED_DISK_SPACE" = true ]; then
    print_header "System Validation Checks"

    # Check for sudo availability (if needed)
    if [ "$NEED_SUDO" = true ]; then
        print_step "Checking sudo availability..."
        if ! command_exists sudo; then
            print_error "sudo is not installed. Please install sudo first: pacman -S sudo"
            exit 1
        fi

        if ! sudo -v &>/dev/null; then
            print_error "You don't have sudo privileges. Please ensure you're in the sudoers group."
            exit 1
        fi
        print_success "sudo is available and configured"
    fi

    # Check internet connectivity (if needed)
    if [ "$NEED_INTERNET" = true ]; then
        print_step "Checking internet connectivity..."
        if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null && ! ping -c 1 -W 3 1.1.1.1 &>/dev/null; then
            print_error "No internet connection detected. This script requires internet access."
            print_error "Please check your network connection and try again."
            exit 1
        fi
        print_success "Internet connection verified"
    fi

    # Check disk space (if needed)
    if [ "$NEED_DISK_SPACE" = true ]; then
        print_step "Checking available disk space..."
        AVAILABLE_ROOT=$(df / | awk 'NR==2 {print int($4/1024)}')  # Available space in MB
        if [ "$AVAILABLE_ROOT" -lt "$MIN_ROOT_SPACE_MB" ]; then
            print_error "Insufficient disk space. At least ${MIN_ROOT_SPACE_MB}MB free space is required."
            print_error "Available: ${AVAILABLE_ROOT}MB"
            exit 1
        fi

        # Check /boot separately if it's a separate partition
        if mountpoint -q /boot; then
            AVAILABLE_BOOT=$(df /boot | awk 'NR==2 {print int($4/1024)}')  # Available space in MB
            if [ "$AVAILABLE_BOOT" -lt "$MIN_BOOT_SPACE_MB" ]; then
                print_error "Insufficient disk space in /boot. At least ${MIN_BOOT_SPACE_MB}MB free space is required."
                print_error "Available: ${AVAILABLE_BOOT}MB"
                exit 1
            fi
        fi
        print_success "Sufficient disk space available (${AVAILABLE_ROOT}MB on /)"
    fi
fi

################################################################################
# 0. Install Mainline Kernel (Optional)
################################################################################

if [ "$INSTALL_MAINLINE" = true ]; then
    print_header "Installing Mainline Kernel"

    # Check if Chaotic-AUR is already fully configured
    CHAOTIC_CONFIGURED=false
    if grep -q "\[chaotic-aur\]" /etc/pacman.conf 2>/dev/null && \
       grep -q "Include = /etc/pacman.d/chaotic-mirrorlist" /etc/pacman.conf 2>/dev/null; then
        CHAOTIC_CONFIGURED=true
        print_skip "Chaotic-AUR repository already fully configured"
    fi

    if [ "$CHAOTIC_CONFIGURED" = false ]; then
        # Import GPG key
        print_step "Importing Chaotic-AUR GPG key..."
        if sudo pacman-key --list-keys 3056513887B78AEB &>/dev/null; then
            print_skip "Chaotic-AUR GPG key already imported"
        else
            sudo pacman-key --recv-key 3056513887B78AEB --keyserver keyserver.ubuntu.com
            sudo pacman-key --lsign-key 3056513887B78AEB
            print_success "Chaotic-AUR GPG key imported"
        fi

        # Install mirrorlist
        if ! package_installed "chaotic-mirrorlist"; then
            print_step "Installing Chaotic-AUR mirrorlist..."
            sudo pacman -U https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-mirrorlist.pkg.tar.zst --noconfirm
            print_success "Chaotic-AUR mirrorlist installed"
        else
            print_skip "Chaotic-AUR mirrorlist already installed"
        fi

        # Install keyring (contains all trusted keys for Chaotic-AUR packages)
        if ! package_installed "chaotic-keyring"; then
            print_step "Installing Chaotic-AUR keyring..."
            sudo pacman -U https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-keyring.pkg.tar.zst --noconfirm
            print_success "Chaotic-AUR keyring installed"
        else
            print_skip "Chaotic-AUR keyring already installed"
        fi

        # Add repository to pacman.conf if not already present
        if ! grep -q "\[chaotic-aur\]" /etc/pacman.conf 2>/dev/null; then
            print_step "Adding Chaotic-AUR repository to pacman.conf..."
            echo '
[chaotic-aur]
Include = /etc/pacman.d/chaotic-mirrorlist' | sudo tee -a /etc/pacman.conf >/dev/null
            print_success "Chaotic-AUR repository added"
        else
            # Header exists but maybe not the Include line
            if ! grep -q "Include = /etc/pacman.d/chaotic-mirrorlist" /etc/pacman.conf 2>/dev/null; then
                print_error "Chaotic-AUR header found but Include line missing in pacman.conf"
                print_error "Please manually fix /etc/pacman.conf"
                exit 1
            fi
        fi
    fi

    print_step "Updating package database..."
    sudo pacman -Syy --noconfirm
    print_success "Package database updated"

    # Refresh keyring to ensure all package signing keys are trusted
    print_step "Refreshing package signing keys..."
    sudo pacman -S --noconfirm chaotic-keyring
    print_success "Package signing keys refreshed"

    if package_installed "linux-mainline"; then
        print_skip "linux-mainline kernel already installed"
    else
        print_step "Installing linux-mainline kernel..."
        sudo pacman -S --noconfirm linux-mainline
        print_success "linux-mainline kernel installed"
    fi

    # Update bootloader configuration
    print_step "Updating bootloader configuration..."
    if [ -f /boot/limine.conf ]; then
        print_step "Setting mainline kernel as default for Limine..."
        # Find the index of the linux-mainline entry
        MAINLINE_INDEX=$(grep -n "//linux-mainline" /boot/limine.conf | head -1 | cut -d: -f1)
        if [ -n "$MAINLINE_INDEX" ]; then
            # Count how many boot entries exist before the mainline entry
            # Entries start with "//" (2 slashes) but not "///" (3 slashes which are submenus)
            ENTRY_INDEX=$(awk -v line="$MAINLINE_INDEX" 'NR < line && /^  \/\/[^\/]/ {count++} END {print count}' /boot/limine.conf)

            # Update default_entry in limine.conf
            sudo sed -i "s/^default_entry:.*/default_entry: $ENTRY_INDEX/" /boot/limine.conf
            print_success "Mainline kernel (entry $ENTRY_INDEX) set as default in Limine"
        else
            print_error "Could not find linux-mainline entry in limine.conf"
        fi
    elif command_exists grub-mkconfig; then
        sudo grub-mkconfig -o /boot/grub/grub.cfg
        print_success "GRUB configuration updated"

        # Set mainline as default in GRUB
        print_step "Setting mainline kernel as default..."
        sudo grub-set-default "Advanced options for Arch Linux>Arch Linux, with Linux linux-mainline" 2>/dev/null || \
        print_error "Could not set default - please set manually in GRUB menu"
    elif command_exists bootctl; then
        print_step "Setting mainline kernel as default for systemd-boot..."
        # Find the mainline boot entry
        MAINLINE_ENTRY=$(ls /boot/loader/entries/*linux-mainline.conf 2>/dev/null | head -1 | xargs basename 2>/dev/null)
        if [ -n "$MAINLINE_ENTRY" ]; then
            echo "default $MAINLINE_ENTRY" | sudo tee /boot/loader/loader.conf >/dev/null
            print_success "Mainline kernel set as default"
        else
            print_error "Could not find mainline boot entry - please set manually"
        fi
    else
        print_error "Unknown bootloader - please update manually"
    fi

    echo -e "${YELLOW}⚠${NC}  ${BOLD}Reboot required to use the mainline kernel${NC}\n"
fi

################################################################################
# 1. Install Claude Code
################################################################################

if [ "$INSTALL_CLAUDE" = true ]; then
    print_header "Installing Claude Code"

    if command_exists claude; then
        print_skip "Claude Code is already installed"
        CLAUDE_VERSION=$(claude --version 2>/dev/null || echo "unknown")
        print_step "Current version: $CLAUDE_VERSION"
    else
        print_step "Installing Claude Code using official installer..."

        # Download installer to temp file first (safer than pipe-to-bash)
        CLAUDE_INSTALLER=$(mktemp)
        if curl -fsSL https://claude.ai/install -o "$CLAUDE_INSTALLER"; then
            chmod +x "$CLAUDE_INSTALLER"
            if bash "$CLAUDE_INSTALLER"; then
                print_success "Claude Code installed successfully"
            else
                print_error "Failed to install Claude Code"
                print_error "Please try running manually: curl -fsSL https://claude.ai/install | bash"
                rm -f "$CLAUDE_INSTALLER"
                exit 1
            fi
            rm -f "$CLAUDE_INSTALLER"
        else
            print_error "Failed to download Claude Code installer"
            rm -f "$CLAUDE_INSTALLER"
            exit 1
        fi
    fi

    # Reload bashrc to update PATH
    print_step "Reloading .bashrc to update PATH..."
    if [ -f "$HOME/.bashrc" ]; then
        # Source bashrc for current session
        set +e  # Temporarily disable exit on error
        source "$HOME/.bashrc" 2>/dev/null
        set -e  # Re-enable exit on error
        print_success "PATH updated for current session"
    else
        print_error ".bashrc not found - you may need to manually update your PATH"
    fi

    # Verify installation
    if command_exists claude; then
        CLAUDE_VERSION=$(claude --version 2>/dev/null || echo "installed")
        print_success "Claude Code is ready to use (version: $CLAUDE_VERSION)"
    else
        print_error "Claude Code installation completed but 'claude' command not found in PATH"
        print_error "You may need to restart your shell or manually add Claude to your PATH"
    fi
fi

################################################################################
# 3. Install Codex CLI
################################################################################

if [ "$INSTALL_CODEX" = true ]; then
    print_header "Installing Codex CLI"

    # Check Node.js is available and version
    print_step "Checking Node.js version..."
    if ! command_exists node; then
        print_error "Node.js is not installed but should be available with npm package"
        print_error "Please ensure Node.js is installed or run: ./install packages codex"
        exit 1
    fi

    NODE_VERSION=$(node --version 2>/dev/null | sed 's/v//')
    NODE_MAJOR=$(echo "$NODE_VERSION" | cut -d. -f1)
    if [ "$NODE_MAJOR" -lt "$MIN_NODE_VERSION" ]; then
        print_error "Node.js version $NODE_VERSION is too old. Minimum required: v${MIN_NODE_VERSION}.0.0"
        exit 1
    fi
    print_success "Node.js $NODE_VERSION detected"

    # Ensure ~/.local/bin exists
    mkdir -p "$HOME/.local/bin"

    if command_exists codex; then
        print_step "Updating Codex CLI to latest version..."
        npm install -g @openai/codex --prefix "$HOME/.local"
        print_success "Codex CLI updated"
    else
        print_step "Installing Codex CLI globally..."
        npm install -g @openai/codex --prefix "$HOME/.local"
        print_success "Codex CLI installed"
    fi

    # Add ~/.local/bin to PATH if not already present in .bashrc
    # More flexible pattern matching for existing PATH entries
    if ! grep -qE '(\.local/bin|HOME/.local/bin)' "$HOME/.bashrc" 2>/dev/null; then
        print_step "Adding ~/.local/bin to PATH in .bashrc..."
        echo '' >> "$HOME/.bashrc"
        echo '# Added by Omarchy post-install script' >> "$HOME/.bashrc"
        echo 'export PATH=$HOME/.local/bin:$PATH' >> "$HOME/.bashrc"
        print_success "PATH updated in .bashrc"

        # Update current PATH if not already present
        if ! echo "$PATH" | grep -q "$HOME/.local/bin"; then
            export PATH="$HOME/.local/bin:$PATH"
            print_step "PATH updated for current session"
        fi
    else
        print_skip "PATH already configured in .bashrc"
    fi
fi

################################################################################
# 4. Configure Screensaver
################################################################################

if [ "$INSTALL_SCREENSAVER" = true ]; then
    print_header "Configuring Screensaver"

    SCREENSAVER_SRC="$SCRIPT_DIR/config/screensaver/screensaver.txt"
    SCREENSAVER_DEST="$HOME/.config/omarchy/branding/screensaver.txt"

    deploy_config_file "$SCREENSAVER_SRC" "$SCREENSAVER_DEST" "screensaver.txt"
fi

################################################################################
# 5. Install Plymouth Theme
################################################################################

if [ "$INSTALL_PLYMOUTH" = true ]; then
    print_header "Installing Plymouth Theme (Cybex)"

    PLYMOUTH_SRC="$SCRIPT_DIR/config/plymouth/themes/cybex"
    PLYMOUTH_DEST="/usr/share/plymouth/themes/cybex"

    if [ ! -d "$PLYMOUTH_SRC" ]; then
        print_error "Source Plymouth theme not found at $PLYMOUTH_SRC"
        print_error "Skipping Plymouth theme installation..."
    else
        # Install theme files (excluding .claude directory)
        if [ ! -d "$PLYMOUTH_DEST" ]; then
            print_step "Installing Plymouth theme to $PLYMOUTH_DEST..."
            sudo mkdir -p "$PLYMOUTH_DEST"
            # Copy all files except hidden directories like .claude
            (cd "$PLYMOUTH_SRC" && sudo find . -type f ! -path '*/\.*' -exec cp --parents {} "$PLYMOUTH_DEST/" \;)
            print_success "Plymouth theme files installed"
        else
            print_skip "Plymouth theme directory already exists"
            print_step "Updating Plymouth theme files..."
            # Copy all files except hidden directories like .claude
            (cd "$PLYMOUTH_SRC" && sudo find . -type f ! -path '*/\.*' -exec cp --parents {} "$PLYMOUTH_DEST/" \;)
            print_success "Plymouth theme files updated"
        fi

        # Check if plymouth-set-default-theme command exists
        if ! command_exists plymouth-set-default-theme; then
            print_error "plymouth-set-default-theme command not found"
            print_error "Install Plymouth first: sudo pacman -S plymouth"
        else
            # Check if theme is already set
            CURRENT_THEME=$(sudo plymouth-set-default-theme)
            if [ "$CURRENT_THEME" = "cybex" ]; then
                print_skip "Plymouth theme 'cybex' is already active"
            else
                print_step "Setting Plymouth theme to 'cybex'..."
                sudo plymouth-set-default-theme -R cybex
                print_success "Plymouth theme 'cybex' enabled"
                print_step "Rebuilding initramfs (this may take a moment)..."
                if ! sudo mkinitcpio -P; then
                    print_error "CRITICAL: Failed to rebuild initramfs!"
                    print_error "Your system may not boot properly with the new theme."
                    print_error "Please try running 'sudo mkinitcpio -P' manually and check for errors."
                    print_error "Common issues: insufficient /boot space, missing kernel modules, or hook errors."
                    exit 1
                fi
                print_success "Initramfs rebuilt successfully"
            fi
        fi
    fi
fi

################################################################################
# 6. Install Fish Shell with Starship Prompt
################################################################################

if [ "$INSTALL_FISH" = true ]; then
    print_header "Installing Fish Shell"

    # Install omarchy-fish package
    if package_installed "omarchy-fish"; then
        print_skip "omarchy-fish package already installed"
    else
        print_step "Installing omarchy-fish package..."
        sudo pacman -S --needed --noconfirm omarchy-fish
        print_success "omarchy-fish package installed"
    fi

    # Run omarchy-setup-fish to configure bash→Fish transition
    # This creates a backup of .bashrc and sets up auto-launch of Fish from bash
    if grep -q "exec fish" "$HOME/.bashrc" 2>/dev/null || grep -q "fish" "$HOME/.bashrc" 2>/dev/null; then
        print_skip "Fish shell auto-launch already configured in .bashrc"
    else
        print_step "Configuring Fish shell auto-launch..."
        if command_exists omarchy-setup-fish; then
            omarchy-setup-fish
            print_success "Fish shell configured (bash will auto-launch Fish)"
        else
            print_error "omarchy-setup-fish command not found"
            print_error "Fish shell may not launch automatically from bash"
        fi
    fi

    # Configure Starship prompt
    STARSHIP_SRC="$SCRIPT_DIR/config/starship/starship.toml"
    STARSHIP_DEST="$HOME/.config/starship.toml"

    deploy_config_file "$STARSHIP_SRC" "$STARSHIP_DEST" "starship.toml"

    # Configure Fish shell with custom config
    FISH_CONFIG_SRC="$SCRIPT_DIR/config/fish/config.fish"
    FISH_CONFIG_DEST="$HOME/.config/fish/config.fish"

    deploy_config_file "$FISH_CONFIG_SRC" "$FISH_CONFIG_DEST" "config.fish"

    echo -e "${GREEN}Fish shell installed successfully!${NC}"
    echo -e "Features included:"
    echo -e "  • Native Fish autosuggestions and syntax highlighting"
    echo -e "  • Starship prompt (configured via ~/.config/starship.toml)"
    echo -e "  • fzf keybindings (Ctrl+R for history, Ctrl+Alt+F for directories)"
    echo -e "  • Smart directory navigation (zoxide, eza)"
    echo -e ""
fi

################################################################################
# 7. Generate SSH Key for GitHub
################################################################################

if [ "$INSTALL_SSH" = true ]; then
    print_header "Generating SSH Key for GitHub"

    SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
    SSH_PUB_KEY="$SSH_KEY_PATH.pub"

    # Ensure .ssh directory exists with correct permissions
    mkdir -p "$HOME/.ssh"
    chmod 700 "$HOME/.ssh"

    if [ -f "$SSH_KEY_PATH" ]; then
        print_skip "SSH key already exists at $SSH_KEY_PATH"
    else
        print_step "Generating new ED25519 SSH key..."
        ssh-keygen -t ed25519 -C "$(whoami)@$(hostname)" -f "$SSH_KEY_PATH" -N ""
        print_success "SSH key generated"
    fi

    # Check for ssh-agent configuration
    print_step "Checking SSH agent configuration..."

    # Check if ssh-agent is already configured to start automatically
    SSH_AGENT_CONFIGURED=false
    if grep -q "SSH_AUTH_SOCK" "$HOME/.bashrc" 2>/dev/null || grep -q "ssh-agent" "$HOME/.bashrc" 2>/dev/null; then
        SSH_AGENT_CONFIGURED=true
        print_skip "SSH agent startup already configured in .bashrc"
    fi

    # If not configured, add ssh-agent startup to .bashrc
    if [ "$SSH_AGENT_CONFIGURED" = false ]; then
        print_step "Adding SSH agent configuration to .bashrc..."
        cat >> "$HOME/.bashrc" << 'EOF'

# SSH Agent configuration (added by Omarchy post-install script)
if [ -z "$SSH_AUTH_SOCK" ]; then
    eval "$(ssh-agent -s)" >/dev/null 2>&1
fi
EOF
        print_success "SSH agent configuration added to .bashrc"
    fi

    # Try to add key to current agent if running, or start a new one
    set +e  # Temporarily disable exit on error
    ssh-add -l &>/dev/null
    SSH_AGENT_STATUS=$?

    if [ "$SSH_AGENT_STATUS" -eq 0 ] || [ "$SSH_AGENT_STATUS" -eq 1 ]; then
        # Agent is running (0 = has keys, 1 = no keys)
        if ssh-add -l 2>/dev/null | grep -q "$SSH_KEY_PATH"; then
            print_skip "SSH key already loaded in current ssh-agent"
        else
            print_step "Adding SSH key to current ssh-agent..."
            ssh-add "$SSH_KEY_PATH" 2>/dev/null
            if [ $? -eq 0 ]; then
                print_success "SSH key added to ssh-agent"
            else
                print_error "Failed to add key to ssh-agent (may need manual 'ssh-add ~/.ssh/id_ed25519')"
            fi
        fi
    elif [ "$SSH_AGENT_STATUS" -eq 2 ]; then
        # No agent running, start one for this session
        print_step "Starting ssh-agent for current session..."
        eval "$(ssh-agent -s)" >/dev/null 2>&1
        ssh-add "$SSH_KEY_PATH" 2>/dev/null
        if [ $? -eq 0 ]; then
            print_success "SSH agent started and key added for current session"
            print_skip "Note: This agent is temporary. A persistent one will start on next login."
        else
            print_error "Failed to add key to ssh-agent (may need manual 'ssh-add ~/.ssh/id_ed25519')"
        fi
    fi
    set -e  # Re-enable exit on error
fi

################################################################################
# 8. Configure Passwordless Sudo
################################################################################

if [ "$INSTALL_PASSWORDLESS_SUDO" = true ]; then
    print_header "Configuring Passwordless Sudo"

    SUDOERS_FILE="/etc/sudoers.d/$(whoami)"
    SUDOERS_CONTENT="$(whoami) ALL=(ALL) NOPASSWD: ALL"

    # Check if already configured
    if sudo test -f "$SUDOERS_FILE"; then
        if sudo grep -q "NOPASSWD: ALL" "$SUDOERS_FILE" 2>/dev/null; then
            print_skip "Passwordless sudo already configured"
        else
            # File exists but different content - update it with validation
            print_step "Updating passwordless sudo configuration..."
            TEMP_SUDOERS=$(mktemp)
            echo "$SUDOERS_CONTENT" > "$TEMP_SUDOERS"

            if sudo visudo -c -f "$TEMP_SUDOERS" &>/dev/null; then
                sudo cp "$TEMP_SUDOERS" "$SUDOERS_FILE"
                sudo chmod 440 "$SUDOERS_FILE"
                print_success "Passwordless sudo updated"
            else
                print_error "Failed to validate sudoers syntax"
                rm -f "$TEMP_SUDOERS"
                exit 1
            fi
            rm -f "$TEMP_SUDOERS"
        fi
    else
        print_step "Creating sudoers file for $(whoami)..."

        # Create temp file and validate
        TEMP_SUDOERS=$(mktemp)
        echo "$SUDOERS_CONTENT" > "$TEMP_SUDOERS"

        if sudo visudo -c -f "$TEMP_SUDOERS" &>/dev/null; then
            sudo cp "$TEMP_SUDOERS" "$SUDOERS_FILE"
            sudo chmod 440 "$SUDOERS_FILE"
            sudo chown root:root "$SUDOERS_FILE"
            print_success "Passwordless sudo enabled for $(whoami)"
        else
            print_error "Failed to validate sudoers syntax"
            rm -f "$TEMP_SUDOERS"
            exit 1
        fi
        rm -f "$TEMP_SUDOERS"
    fi
fi

################################################################################
# 9. Configure Hyprland Bindings
################################################################################

if [ "$INSTALL_HYPRLAND_BINDINGS" = true ]; then
    print_header "Configuring Hyprland Bindings"

    HYPRLAND_BINDINGS_SRC="$SCRIPT_DIR/config/hyprland/bindings.conf"
    HYPRLAND_BINDINGS_DEST="$HOME/.config/hypr/bindings.conf"

    if [ ! -f "$HYPRLAND_BINDINGS_SRC" ]; then
        print_error "Source bindings.conf not found at $HYPRLAND_BINDINGS_SRC"
        print_error "Skipping Hyprland bindings configuration..."
    else
        # Create destination directory if it doesn't exist
        mkdir -p "$(dirname "$HYPRLAND_BINDINGS_DEST")"

        if [ -f "$HYPRLAND_BINDINGS_DEST" ]; then
            print_step "Backing up existing bindings.conf..."
            BACKUP_FILE=$(create_backup "$HYPRLAND_BINDINGS_DEST")
            print_success "Backup created at $BACKUP_FILE"
            print_step "Updating Hyprland bindings.conf..."
            cp "$HYPRLAND_BINDINGS_SRC" "$HYPRLAND_BINDINGS_DEST"
            print_success "Hyprland bindings updated"
        else
            print_step "Copying bindings.conf to $HYPRLAND_BINDINGS_DEST..."
            cp "$HYPRLAND_BINDINGS_SRC" "$HYPRLAND_BINDINGS_DEST"
            print_success "Hyprland bindings configured"
        fi
    fi

    HYPRLAND_INPUT_SRC="$SCRIPT_DIR/config/hyprland/input.conf"
    HYPRLAND_INPUT_DEST="$HOME/.config/hypr/input.conf"

    if [ ! -f "$HYPRLAND_INPUT_SRC" ]; then
        print_error "Source input.conf not found at $HYPRLAND_INPUT_SRC"
        print_error "Skipping Hyprland input configuration..."
    else
        # Create destination directory if it doesn't exist
        mkdir -p "$(dirname "$HYPRLAND_INPUT_DEST")"

        if [ -f "$HYPRLAND_INPUT_DEST" ]; then
            print_step "Backing up existing input.conf..."
            BACKUP_FILE=$(create_backup "$HYPRLAND_INPUT_DEST")
            print_success "Backup created at $BACKUP_FILE"
            print_step "Updating Hyprland input.conf..."
            cp "$HYPRLAND_INPUT_SRC" "$HYPRLAND_INPUT_DEST"
            print_success "Hyprland input configuration updated"
        else
            print_step "Copying input.conf to $HYPRLAND_INPUT_DEST..."
            cp "$HYPRLAND_INPUT_SRC" "$HYPRLAND_INPUT_DEST"
            print_success "Hyprland input configuration configured"
        fi
    fi
fi

################################################################################
# 10. Install and Configure Waycorner (Hot Corners)
################################################################################

if [ "$INSTALL_WAYCORNER" = true ]; then
    print_header "Installing Waycorner (Hot Corners)"

    # Ensure cargo is available
    if ! command_exists cargo; then
        print_error "Rust/Cargo is not installed. Waycorner requires Rust to compile."
        print_error "Install Rust first: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
        exit 1
    fi

    # Check if waycorner is already installed
    if command_exists waycorner || [ -f "$HOME/.cargo/bin/waycorner" ]; then
        print_skip "Waycorner is already installed"
    else
        print_step "Installing waycorner via cargo (this may take a few minutes)..."
        cargo install waycorner --locked
        print_success "Waycorner installed"
    fi

    # Configure waycorner
    WAYCORNER_SRC="$SCRIPT_DIR/config/waycorner/config.toml"
    WAYCORNER_DEST="$HOME/.config/waycorner/config.toml"

    deploy_config_file "$WAYCORNER_SRC" "$WAYCORNER_DEST" "waycorner config.toml"

    # Add waycorner to Hyprland autostart
    HYPRLAND_AUTOSTART="$HOME/.config/hypr/autostart.conf"

    if [ -f "$HYPRLAND_AUTOSTART" ]; then
        if grep -q "waycorner" "$HYPRLAND_AUTOSTART"; then
            print_skip "Waycorner already in Hyprland autostart"
        else
            print_step "Adding waycorner to Hyprland autostart..."
            echo "" >> "$HYPRLAND_AUTOSTART"
            echo "# Hot corners" >> "$HYPRLAND_AUTOSTART"
            echo "exec-once = ~/.cargo/bin/waycorner" >> "$HYPRLAND_AUTOSTART"
            print_success "Waycorner added to Hyprland autostart"
        fi
    else
        print_error "Hyprland autostart.conf not found at $HYPRLAND_AUTOSTART"
        print_error "You'll need to manually add 'exec-once = ~/.cargo/bin/waycorner' to your Hyprland config"
    fi

    print_step "Starting waycorner for current session..."
    if pgrep -x waycorner >/dev/null 2>&1; then
        print_skip "Waycorner is already running"
    else
        "$HOME/.cargo/bin/waycorner" &>/dev/null &
        print_success "Waycorner started"
    fi
fi

################################################################################
# 11. Configure Waybar Idle Toggle
################################################################################

if [ "$INSTALL_WAYBAR" = true ]; then
    print_header "Configuring Waybar Idle Toggle"

    WAYBAR_CONFIG_DEST="$HOME/.config/waybar/config.jsonc"
    WAYBAR_STYLE_DEST="$HOME/.config/waybar/style.css"
    INDICATOR_SRC="$SCRIPT_DIR/config/waybar/indicators/idle-toggle.sh"
    INDICATOR_DEST="$HOME/.local/share/omarchy/default/waybar/indicators/idle-toggle.sh"

    # Check if waybar config exists
    if [ ! -f "$WAYBAR_CONFIG_DEST" ]; then
        print_error "Waybar config not found at $WAYBAR_CONFIG_DEST"
        print_error "Please ensure Waybar is configured before adding idle toggle"
    else
        # Check if idle-toggle is already configured in config.jsonc
        if grep -q '"custom/idle-toggle"' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
            print_skip "Waybar idle toggle module already present in config.jsonc"
        else
            print_step "Adding idle toggle module to waybar config.jsonc..."

            # Create backup
            BACKUP_FILE=$(create_backup "$WAYBAR_CONFIG_DEST")
            print_success "Backup created at $BACKUP_FILE"

            # Add to modules-right array (look for common module to insert after)
            # Try to insert after group/tray-expander, or bluetooth, or network as fallback
            MODULE_ADDED=false
            if grep -q '"group/tray-expander"' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                sed -i '/"group\/tray-expander",/a\    "custom/idle-toggle",' "$WAYBAR_CONFIG_DEST"
                MODULE_ADDED=true
            elif grep -q '"bluetooth"' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                sed -i '/"bluetooth"/i\    "custom/idle-toggle",' "$WAYBAR_CONFIG_DEST"
                MODULE_ADDED=true
            elif grep -q '"network"' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                sed -i '/"network"/i\    "custom/idle-toggle",' "$WAYBAR_CONFIG_DEST"
                MODULE_ADDED=true
            fi

            # Verify the module reference was added
            if [ "$MODULE_ADDED" = true ] && ! grep -q '"custom/idle-toggle"' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                print_error "Failed to add idle-toggle to modules array"
                print_error "Please manually add \"custom/idle-toggle\" to modules-right"
            fi

            # Add module definition (insert before final closing brace)
            # Look for the "tray" module definition and add after it
            if grep -q '"tray":' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                sed -i '/"tray":/,/^  \}/{
                    /^  \}/a\  ,\n  "custom/idle-toggle": {\n    "exec": "$OMARCHY_PATH/default/waybar/indicators/idle-toggle.sh",\n    "on-click": "omarchy-toggle-idle",\n    "return-type": "json",\n    "interval": 3,\n    "signal": 9\n  }
                }' "$WAYBAR_CONFIG_DEST"
            else
                # Fallback: add before final closing brace
                sed -i '$i\  ,\n  "custom/idle-toggle": {\n    "exec": "$OMARCHY_PATH/default/waybar/indicators/idle-toggle.sh",\n    "on-click": "omarchy-toggle-idle",\n    "return-type": "json",\n    "interval": 3,\n    "signal": 9\n  }' "$WAYBAR_CONFIG_DEST"
            fi

            # Verify the module definition was added
            if grep -q '"custom/idle-toggle":' "$WAYBAR_CONFIG_DEST" 2>/dev/null; then
                print_success "Idle toggle module added to waybar config"
            else
                print_error "Failed to add idle-toggle module definition"
                print_error "Please manually add the custom/idle-toggle module to your waybar config"
            fi
        fi
    fi

    # Check if waybar style exists
    if [ ! -f "$WAYBAR_STYLE_DEST" ]; then
        print_error "Waybar style.css not found at $WAYBAR_STYLE_DEST"
        print_error "Please ensure Waybar is configured before adding idle toggle"
    else
        # Check if idle-toggle styles already exist
        if grep -q '#custom-idle-toggle' "$WAYBAR_STYLE_DEST" 2>/dev/null; then
            print_skip "Waybar idle toggle styles already present in style.css"
        else
            print_step "Adding idle toggle styles to waybar style.css..."

            # Create backup
            BACKUP_FILE=$(create_backup "$WAYBAR_STYLE_DEST")
            print_success "Backup created at $BACKUP_FILE"

            # Append theme-adaptive styles to end of file
            cat >> "$WAYBAR_STYLE_DEST" << 'EOF'

#custom-idle-toggle {
  min-width: 12px;
  margin-right: 17px;
}

#custom-idle-toggle.on {
  color: @foreground;
  opacity: 1.0;
}

#custom-idle-toggle.off {
  color: @foreground;
  opacity: 0.35;
}
EOF
            print_success "Idle toggle styles added to waybar style.css"
        fi
    fi

    # Install indicator script
    deploy_config_file "$INDICATOR_SRC" "$INDICATOR_DEST" "idle-toggle.sh" true

    if [ -f "$INDICATOR_DEST" ]; then
        print_step "Restarting Waybar to apply changes..."
        if command_exists omarchy-restart-waybar; then
            omarchy-restart-waybar &>/dev/null
            print_success "Waybar restarted"
        else
            if pgrep -x waybar >/dev/null 2>&1; then
                pkill -x waybar
                sleep 0.5
                waybar &>/dev/null &
                print_success "Waybar restarted"
            else
                print_skip "Waybar is not running"
            fi
        fi
    fi
fi

################################################################################
# 12. Install Brave Browser
################################################################################

if [ "$INSTALL_BRAVE" = true ]; then
    print_header "Installing Brave Browser"

    # Install brave-bin package
    if package_installed "brave-bin"; then
        print_skip "Brave browser is already installed"
    else
        print_step "Installing brave-bin package from AUR..."
        yay -S --needed --noconfirm brave-bin
        print_success "Brave browser installed"
    fi

    # Configure default browser in uwsm
    UWSM_DEFAULT="$HOME/.config/uwsm/default"
    UWSM_DIR="$HOME/.config/uwsm"

    # Create uwsm config directory if it doesn't exist
    if [ ! -d "$UWSM_DIR" ]; then
        print_step "Creating uwsm config directory..."
        mkdir -p "$UWSM_DIR"
        print_success "uwsm config directory created"
    fi

    # Check if default file exists, create if not
    if [ ! -f "$UWSM_DEFAULT" ]; then
        print_step "Creating uwsm default configuration..."
        cat > "$UWSM_DEFAULT" << 'EOF'
# Changes require a restart to take effect.

# Browser
export BROWSER=brave
EOF
        print_success "uwsm default configuration created with Brave as default browser"
    else
        # File exists, check if BROWSER is already set to brave
        if grep -q "^export BROWSER=brave" "$UWSM_DEFAULT" 2>/dev/null; then
            print_skip "BROWSER already set to brave in uwsm default"
        elif grep -q "^export BROWSER=" "$UWSM_DEFAULT" 2>/dev/null; then
            # BROWSER is set to something else, update it
            print_step "Updating BROWSER setting in uwsm default..."
            # Create backup first
            BACKUP_FILE=$(create_backup "$UWSM_DEFAULT")
            if [ -n "$BACKUP_FILE" ]; then
                print_success "Backup created at $BACKUP_FILE"
            fi
            # Update the BROWSER line
            sed -i 's|^export BROWSER=.*|export BROWSER=brave|' "$UWSM_DEFAULT"
            print_success "BROWSER updated to brave in uwsm default"
        else
            # BROWSER line doesn't exist, add it
            print_step "Adding BROWSER setting to uwsm default..."
            # Create backup first
            BACKUP_FILE=$(create_backup "$UWSM_DEFAULT")
            if [ -n "$BACKUP_FILE" ]; then
                print_success "Backup created at $BACKUP_FILE"
            fi
            # Add BROWSER line after a comment if there's none, or at the end
            if grep -q "# Browser" "$UWSM_DEFAULT" 2>/dev/null; then
                # Add after the existing comment
                sed -i '/# Browser/a export BROWSER=brave' "$UWSM_DEFAULT"
            else
                # Add at the end with a comment
                echo "" >> "$UWSM_DEFAULT"
                echo "# Browser" >> "$UWSM_DEFAULT"
                echo "export BROWSER=brave" >> "$UWSM_DEFAULT"
            fi
            print_success "BROWSER set to brave in uwsm default"
        fi
    fi

    echo -e "${GREEN}Brave browser installed and configured as default!${NC}"
    echo -e "Note: You may need to restart your session for the BROWSER change to take effect.\n"
fi

# ============================================================================
# NOCTALIA SHELL
# ============================================================================
if [ "$INSTALL_NOCTALIA" = true ]; then
    print_header "Installing Noctalia Shell"

    HYPRLAND_AUTOSTART="$HOME/.config/hypr/autostart.conf"

    # Install package if not present
    if ! package_installed "noctalia-shell"; then
        print_step "Installing noctalia-shell package..."
        yay -S --needed --noconfirm noctalia-shell
        print_success "noctalia-shell package installed"
    else
        print_skip "noctalia-shell package already installed"
    fi

    # Disable default Omarchy autostart in hyprland.conf (prevents waybar/mako/swayosd/swaybg from starting)
    HYPRLAND_CONF="$HOME/.config/hypr/hyprland.conf"
    if [ -f "$HYPRLAND_CONF" ] && grep -q "^source = ~/.local/share/omarchy/default/hypr/autostart.conf" "$HYPRLAND_CONF"; then
        print_step "Disabling Omarchy default autostart..."
        sed -i 's|^source = ~/.local/share/omarchy/default/hypr/autostart.conf|# source = ~/.local/share/omarchy/default/hypr/autostart.conf  # Disabled by Cybex - Noctalia Shell|' "$HYPRLAND_CONF"
        print_success "Omarchy default autostart disabled"
    elif grep -q "Disabled by Cybex - Noctalia Shell" "$HYPRLAND_CONF" 2>/dev/null; then
        print_skip "Omarchy default autostart already disabled"
    else
        print_skip "Omarchy default autostart line not found"
    fi

    # Configure autostart if not already done
    if grep -q "noctalia-shell" "$HYPRLAND_AUTOSTART" 2>/dev/null; then
        print_skip "Noctalia Shell already configured in autostart"
    else
        # Create autostart.conf if it doesn't exist
        mkdir -p "$(dirname "$HYPRLAND_AUTOSTART")"
        touch "$HYPRLAND_AUTOSTART"

        # Add non-conflicting Omarchy autostart items + Noctalia
        print_step "Configuring Noctalia Shell autostart..."
        cat >> "$HYPRLAND_AUTOSTART" << 'EOF'

# Added by Cybex - Noctalia Shell (replaces Omarchy default autostart)
exec-once = uwsm-app -- hypridle
exec-once = uwsm-app -- fcitx5
exec-once = /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
exec-once = omarchy-cmd-first-run
exec-once = systemctl --user import-environment $(env | cut -d'=' -f 1)
exec-once = dbus-update-activation-environment --systemd --all
exec-once = uwsm-app -- qs -c noctalia-shell
EOF
        print_success "Noctalia Shell added to autostart"
    fi

    # Add Noctalia-compatible keybindings for volume/brightness (replaces swayosd-client)
    HYPRLAND_BINDINGS="$HOME/.config/hypr/bindings.conf"
    if grep -q "Noctalia Shell keybindings" "$HYPRLAND_BINDINGS" 2>/dev/null; then
        print_skip "Noctalia keybindings already configured"
    else
        print_step "Adding Noctalia-compatible keybindings..."
        mkdir -p "$(dirname "$HYPRLAND_BINDINGS")"
        cat >> "$HYPRLAND_BINDINGS" << 'EOF'

# Added by Cybex - Noctalia Shell keybindings
# These override the default swayosd-client bindings to work with Noctalia's OSD
bindeld = ,XF86AudioRaiseVolume, Volume up, exec, wpctl set-volume -l 1.0 @DEFAULT_AUDIO_SINK@ 5%+
bindeld = ,XF86AudioLowerVolume, Volume down, exec, wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%-
bindeld = ,XF86AudioMute, Mute, exec, wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle
bindeld = ,XF86AudioMicMute, Mute microphone, exec, wpctl set-mute @DEFAULT_AUDIO_SOURCE@ toggle
bindeld = ,XF86MonBrightnessUp, Brightness up, exec, brightnessctl set 5%+
bindeld = ,XF86MonBrightnessDown, Brightness down, exec, brightnessctl set 5%-
bindld = ,XF86AudioPlay, Play/Pause, exec, playerctl play-pause
bindld = ,XF86AudioPause, Pause, exec, playerctl play-pause
bindld = ,XF86AudioNext, Next track, exec, playerctl next
bindld = ,XF86AudioPrev, Previous track, exec, playerctl previous
EOF
        print_success "Noctalia keybindings added"
    fi

    # Kill conflicting Omarchy services (waybar, mako, swayosd-server, swaybg)
    # These are started by the base Omarchy autostart and conflict with Noctalia's built-in features
    NEED_RESTART=false
    if pgrep -x waybar >/dev/null 2>&1; then
        pkill -x waybar 2>/dev/null || true
        NEED_RESTART=true
    fi
    if pgrep -x mako >/dev/null 2>&1; then
        pkill -x mako 2>/dev/null || true
        NEED_RESTART=true
    fi
    if pgrep -x swayosd-server >/dev/null 2>&1; then
        pkill -x swayosd-server 2>/dev/null || true
        NEED_RESTART=true
    fi
    if pgrep -x swaybg >/dev/null 2>&1; then
        pkill -x swaybg 2>/dev/null || true
        NEED_RESTART=true
    fi

    # Ensure Noctalia is running
    if [ "$NEED_RESTART" = true ]; then
        print_step "Switching to Noctalia Shell..."
        pkill -f "qs.*noctalia-shell" 2>/dev/null || true  # Kill any existing instance to avoid duplicates
        sleep 0.3
        uwsm-app -- qs -c noctalia-shell &>/dev/null &
        print_success "Noctalia Shell activated (replaced waybar, mako, swayosd, swaybg)"
    elif ! pgrep -f "qs.*noctalia-shell" >/dev/null 2>&1; then
        print_step "Starting Noctalia Shell..."
        uwsm-app -- qs -c noctalia-shell &>/dev/null &
        print_success "Noctalia Shell started"
    else
        print_skip "Noctalia Shell is already running"
    fi

    echo ""
    echo -e "${GREEN}Noctalia Shell installed!${NC}"
    echo -e "Notes:"
    echo -e "  • Waybar has been replaced with Noctalia Shell"
    echo -e "  • After Omarchy updates, re-run: ${CYAN}./install noctalia${NC}"
    echo -e "  • To restore Waybar: ${CYAN}./install uninstall noctalia${NC}"
    echo ""
fi

################################################################################
# 13. Configure Hyprland Animations (Look'n'Feel)
################################################################################

if [ "$INSTALL_LOOKNFEEL" = true ]; then
    print_header "Configuring Hyprland Animations"

    LOOKNFEEL_SRC="$SCRIPT_DIR/config/hyprland/looknfeel.conf"
    LOOKNFEEL_DEST="$HOME/.config/hypr/looknfeel.conf"

    deploy_config_file "$LOOKNFEEL_SRC" "$LOOKNFEEL_DEST" "looknfeel.conf"

    echo -e "${GREEN}Hyprland animations configured!${NC}"
    echo -e "Features:"
    echo -e "  • Window slide-in/out animations with overshoot effect"
    echo -e "  • Smooth workspace switching with slide transition"
    echo -e "  • Animated border gradient rotation"
    echo -e "  • Layer animations for menus and notifications"
    echo ""
fi

################################################################################
# Installation Complete
################################################################################

print_header "Installation Complete!"

echo -e "${GREEN}All tasks completed successfully!${NC}\n"

# Only show installed components summary if something was actually installed
if [ "$INSTALL_MAINLINE" = true ] || \
   [ "$INSTALL_CLAUDE" = true ] || [ "$INSTALL_CODEX" = true ] || \
   [ "$INSTALL_SCREENSAVER" = true ] || [ "$INSTALL_PLYMOUTH" = true ] || \
   [ "$INSTALL_FISH" = true ] || \
   [ "$INSTALL_HYPRLAND_BINDINGS" = true ] || \
   [ "$INSTALL_WAYCORNER" = true ] || [ "$INSTALL_WAYBAR" = true ] || \
   [ "$INSTALL_SSH" = true ] || [ "$INSTALL_BRAVE" = true ] || \
   [ "$INSTALL_NOCTALIA" = true ] || [ "$INSTALL_LOOKNFEEL" = true ]; then

    echo -e "${BOLD}Installed/configured components:${NC}"

    if [ "$INSTALL_MAINLINE" = true ]; then
        echo -e "  • ${CYAN}linux-mainline${NC} kernel (Chaotic-AUR)"
    fi

    if [ "$INSTALL_CLAUDE" = true ]; then
        echo -e "  • Claude Code (${CYAN}claude${NC} command)"
    fi

    if [ "$INSTALL_CODEX" = true ]; then
        echo -e "  • Codex CLI (${CYAN}codex${NC} command)"
    fi

    if [ "$INSTALL_SCREENSAVER" = true ]; then
        echo -e "  • Custom screensaver"
    fi

    if [ "$INSTALL_PLYMOUTH" = true ]; then
        echo -e "  • Cybex Plymouth theme"
    fi

    if [ "$INSTALL_FISH" = true ]; then
        echo -e "  • Fish shell (via omarchy-fish)"
        echo -e "  • Starship prompt configuration"
        echo -e "  • Native autosuggestions and syntax highlighting"
        echo -e "  • fzf keybindings and smart navigation tools"
    fi

    if [ "$INSTALL_HYPRLAND_BINDINGS" = true ]; then
        echo -e "  • Hyprland bindings configuration"
    fi

    if [ "$INSTALL_WAYCORNER" = true ]; then
        echo -e "  • Waycorner hot corners for Hyprland"
    fi

    if [ "$INSTALL_WAYBAR" = true ]; then
        echo -e "  • Waybar idle toggle indicator"
    fi

    if [ "$INSTALL_SSH" = true ]; then
        echo -e "  • SSH key for GitHub"
    fi

    if [ "$INSTALL_BRAVE" = true ]; then
        echo -e "  • Brave browser (set as default)"
    fi

    if [ "$INSTALL_NOCTALIA" = true ]; then
        echo -e "  • Noctalia Shell (replaces Waybar)"
    fi

    if [ "$INSTALL_LOOKNFEEL" = true ]; then
        echo -e "  • Hyprland animations (improved look'n'feel)"
    fi

    echo ""
fi

# Show SSH setup instructions only if SSH key was configured
if [ "$INSTALL_SSH" = true ]; then
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${MAGENTA}  GitHub SSH Setup${NC}"
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"

    if [ -f "$HOME/.ssh/id_ed25519.pub" ]; then
        echo -e "${BOLD}Your SSH public key:${NC}\n"
        cat "$HOME/.ssh/id_ed25519.pub"
        echo -e "\n${BOLD}To add this key to GitHub:${NC}"
    else
        echo -e "${RED}SSH public key not found!${NC}\n"
        echo -e "${BOLD}To add your key to GitHub:${NC}"
    fi
    echo -e "  1. Copy the key above (entire line)"
    echo -e "  2. Go to ${CYAN}https://github.com/settings/ssh/new${NC}"
    echo -e "  3. Paste the key and give it a title (e.g., 'Omarchy Linux')"
    echo -e "  4. Click 'Add SSH key'\n"

    echo -e "${BOLD}To test the connection:${NC}"
    echo -e "  ${CYAN}ssh -T git@github.com${NC}\n"
fi

# Next steps section - only show if there are actual next steps
if [ "$INSTALL_CLAUDE" = true ] || [ "$INSTALL_CODEX" = true ] || \
   [ "$INSTALL_MAINLINE" = true ] || [ "$INSTALL_PLYMOUTH" = true ]; then

    echo -e "${BOLD}Next steps:${NC}"

    # PATH update reminder - show only if Claude or Codex were installed
    if [ "$INSTALL_CLAUDE" = true ] || [ "$INSTALL_CODEX" = true ]; then
        echo -e "  • Run ${CYAN}source ~/.bashrc${NC} or restart your shell to update PATH"
    fi

    # Fish shell reminder
    if [ "$INSTALL_FISH" = true ]; then
        echo -e "  • ${BOLD}Restart your shell${NC} to launch Fish shell with Starship prompt"
        echo -e "    Or run: ${CYAN}exec bash${NC} (which will auto-launch Fish)"
    fi

    # Mainline kernel reboot reminder
    if [ "$INSTALL_MAINLINE" = true ]; then
        echo -e "  • ${BOLD}${YELLOW}Reboot to use the mainline kernel${NC}"
    fi

    # Plymouth theme reboot reminder
    if [ "$INSTALL_PLYMOUTH" = true ]; then
        echo -e "  • Reboot to see the new Plymouth boot splash"
    fi

    echo ""
fi
