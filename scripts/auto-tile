#!/usr/bin/env bash

################################################################################
# Hyprland Auto-Tile Helper
#
# Floats the first window on each workspace, recenters it, and reverts to
# tiling once an additional window appears. Works with modern Hyprland releases
# that emit JSON events over the `.socket2.sock` IPC socket.
################################################################################

set -euo pipefail

log() {
    printf '[auto-tile] %s\n' "$*" >&2
}

# Default percentages - will be adjusted based on logical screen size
DEFAULT_FLOAT_WIDTH_PERCENT=60
DEFAULT_FLOAT_HEIGHT_PERCENT=60

# Thresholds for small screens (use larger percentages)
SMALL_SCREEN_WIDTH=1600
SMALL_SCREEN_HEIGHT=1000
SMALL_SCREEN_WIDTH_PERCENT=90
SMALL_SCREEN_HEIGHT_PERCENT=90

# Determine Hyprland runtime dir and instance signature.
HYPR_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/run/user/$(id -u)}/hypr
INSTANCE=${HYPRLAND_INSTANCE_SIGNATURE:-}

if [[ -z "$INSTANCE" ]]; then
    if [[ -d "$HYPR_RUNTIME_DIR" ]]; then
        INSTANCE=$(ls -1 "$HYPR_RUNTIME_DIR" 2>/dev/null | head -n1)
    fi
    if [[ -z "$INSTANCE" ]]; then
        log "Could not determine Hyprland instance signature."
        exit 1
    fi
    log "Auto-detected Hyprland instance: $INSTANCE"
fi

SOCKET="$HYPR_RUNTIME_DIR/$INSTANCE/.socket2.sock"

if [[ ! -S "$SOCKET" ]]; then
    log "Hyprland socket not found at $SOCKET"
    exit 1
fi

declare -A forcedFloating=()
declare -A monitorWidth=()
declare -A monitorHeight=()
declare -A monitorScale=()

refresh_monitors() {
    local monitors_json
    monitors_json=$(hyprctl -j monitors 2>/dev/null) || return

    # Clear existing caches before repopulating.
    monitorWidth=()
    monitorHeight=()
    monitorScale=()

    while IFS=$'\t' read -r mid mw mh ms; do
        [[ -z "$mid" ]] && continue
        monitorWidth["$mid"]=$mw
        monitorHeight["$mid"]=$mh
        monitorScale["$mid"]=$ms
    done < <(echo "$monitors_json" | jq -r '.[] | [.id, .width, .height, .scale] | @tsv')
}

resize_window() {
    local addr=$1
    local monitor_id=$2

    [[ -z "$monitor_id" ]] && return

    local width=${monitorWidth[$monitor_id]:-}
    local height=${monitorHeight[$monitor_id]:-}
    local scale=${monitorScale[$monitor_id]:-}

    if [[ -z "$width" || -z "$height" || -z "$scale" ]]; then
        refresh_monitors
        width=${monitorWidth[$monitor_id]:-}
        height=${monitorHeight[$monitor_id]:-}
        scale=${monitorScale[$monitor_id]:-}
    fi

    if [[ -z "$width" || -z "$height" || -z "$scale" ]]; then
        return
    fi

    # Calculate logical dimensions
    local logical_width=$(awk "BEGIN {printf \"%.0f\", $width / $scale}")
    local logical_height=$(awk "BEGIN {printf \"%.0f\", $height / $scale}")

    # Adjust percentages based on logical screen size
    local width_percent=$DEFAULT_FLOAT_WIDTH_PERCENT
    local height_percent=$DEFAULT_FLOAT_HEIGHT_PERCENT

    if (( logical_width < SMALL_SCREEN_WIDTH )); then
        width_percent=$SMALL_SCREEN_WIDTH_PERCENT
    fi

    if (( logical_height < SMALL_SCREEN_HEIGHT )); then
        height_percent=$SMALL_SCREEN_HEIGHT_PERCENT
    fi

    # Calculate target size in logical coordinates
    local target_w=$(awk "BEGIN {printf \"%.0f\", $logical_width * $width_percent / 100}")
    local target_h=$(awk "BEGIN {printf \"%.0f\", $logical_height * $height_percent / 100}")

    hyprctl dispatch resizewindowpixel "exact $target_w $target_h,address:$addr" >/dev/null 2>&1 || true
}

float_window() {
    local addr=$1
    local is_floating=$2
    local monitor_id=$3

    if [[ "$is_floating" != "true" ]]; then
        hyprctl dispatch togglefloating "address:$addr" >/dev/null 2>&1 || true
    fi
    resize_window "$addr" "$monitor_id"
    hyprctl dispatch centerwindow "address:$addr" >/dev/null 2>&1 || true
    forcedFloating["$addr"]=1
}

tile_window() {
    local addr=$1
    local is_floating=$2

    if [[ "$is_floating" == "true" ]]; then
        hyprctl dispatch togglefloating "address:$addr" >/dev/null 2>&1 || true
    fi
    unset 'forcedFloating[$addr]' || true
}

rebalance_workspaces() {
    local clients
    clients=$(hyprctl -j clients 2>/dev/null) || return

    # Track currently mapped windows so we don't try to manage stale addresses.
    declare -A present=()
    while IFS= read -r addr; do
        [[ -n "$addr" ]] && present["$addr"]=1
    done < <(echo "$clients" | jq -r '.[].address')

    for addr in "${!forcedFloating[@]}"; do
        [[ -z "${present[$addr]:-}" ]] && unset 'forcedFloating[$addr]'
    done

    # Iterate workspaces and enforce floating/tiling.
    while IFS= read -r row; do
        mapfile -t addresses < <(jq -r '.clients[].address' <<<"$row")
        mapfile -t float_states < <(jq -r '.clients[].floating' <<<"$row")
        mapfile -t monitor_ids < <(jq -r '.clients[].monitor' <<<"$row")
        local count=${#addresses[@]}

        if ((count == 1)); then
            local addr=${addresses[0]}
            local state=${float_states[0]}
            local monitor_id=${monitor_ids[0]}
            if [[ -z "${forcedFloating[$addr]:-}" ]]; then
                float_window "$addr" "$state" "$monitor_id"
            fi
        elif ((count > 1)); then
            for idx in "${!addresses[@]}"; do
                local addr=${addresses[$idx]}
                local state=${float_states[$idx]}
                if [[ -n "${forcedFloating[$addr]:-}" ]]; then
                    tile_window "$addr" "$state"
                fi
            done
        fi
    done < <(
        echo "$clients" | jq -rc '
            map(select(.workspace.id >= 0 and .mapped == true and .fullscreen == 0)) |
            sort_by(.workspace.id) |
            group_by(.workspace.id)[] |
            {clients: [.[] | {address: .address, floating: .floating, monitor: .monitor}]}
        '
    )
}

listen_events() {
    while true; do
        socat -U - UNIX-CONNECT:"$SOCKET" | while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local event payload
            event=${line%%>>*}
            payload=${line#*>>}

            case "$event" in
                openwindow|closewindow|movewindow|movewindowv2|workspace|workspacev2|changeworkspace|changefloatingmode)
                    rebalance_workspaces
                    ;;
                *)
                    ;;
            esac
        done

        # Minimal back-off before retrying if the socket stream ends.
        sleep 0.5
    done
}

rebalance_workspaces
listen_events
